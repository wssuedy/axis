"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Event_1 = require("cqrs/dist/lib/Event");
const Snap_1 = require("cqrs/dist/lib/Snap");
const events_1 = require("events");
var { promisify } = require("util");
var mongo = require('then-mongo');
class MongoEventStore extends events_1.EventEmitter {
    constructor(url, collectionNames = { sagas: "", events: "", snaps: "" }) {
        super();
        var db = mongo(url, [collectionNames.sagas || "sagas", collectionNames.sagas || "events", collectionNames.snaps || "snaps"]);
        this.sagas = db.sagas;
        this.events = db.events;
        this.snaps = db.snaps;
    }
    async existSaga(sagaId) {
        return !!await this.getSaga(sagaId);
    }
    async beginSaga(sagaId) {
        const exist = await this.existSaga(sagaId);
        if (!exist) {
            return this.sagas.insert({ sagaId, done: false, alive: true });
        }
    }
    async getSaga(sagaId) {
        return await this.sagas.findOne({ sagaId, alive: true });
    }
    async killSaga(sagaId) {
        return await this.sagas.update({ sagaId }, { alive: false });
    }
    async endSaga(sagaId) {
        const exist = await this.existSaga(sagaId);
        if (exist) {
            return await this.sagas.update({ sagaId }, { done: true });
        }
    }
    async findUndoneSaga() {
        return await this.sagas.find({ done: false });
    }
    async createSnap(snap) {
        return await this.snaps.insert(snap.json);
    }
    async saveEvents(events) {
        events = [].concat(events);
        const eventsJSONArr = events.map(event => {
            return event.json || event;
        });
        await this.events.insert(eventsJSONArr);
        this.emit('saved events', events);
    }
    async getLatestSnapshot(actorId) {
        let data = await this.snaps.find({ actorId }).limit(1).sort({ index: -1, date: -1 });
        if (data && data[0]) {
            return Snap_1.default.parse(data[0]);
        }
    }
    async getEvents(actorId) {
        let events = await this.events.find({ actorId }).sort({ index: -1, date: -1 });
        return events.map(event => Event_1.default.parse(event));
    }
    async getLatestEvent(actorId) {
        let event = await this.events.find({ actorId }).sort({ index: -1, date: -1 }).limit(1);
        return event.length ? Event_1.default.parse(event[0]) : null;
    }
    async getEventsBySnapshot(snapId) {
        const snap = await this.getSnapshotById(snapId);
        if (snap) {
            let events = await this.events.find({
                actorId: snap.actorId,
                index: { '$gt': snap.latestEventIndex }
            }).sort({ date: 1, index: 1 });
            return events.map(event => Event_1.default.parse(event));
        }
    }
    async getSnapshotByIndex(actorId, index) {
        let snap = await this.snaps.findOne({ actorId, index });
        return Snap_1.default.parse(snap);
    }
    async getSnapshotByLastIndex(actorId, index) {
        // let snap = await this.getLatestSnapshot(actorId);
        // if (snap) {
        //     if (index === 0) {
        //         return snap;
        //     } else {
        //         return await this.getSnapshotByIndex(actorId, snap.index - index);
        //     }
        // }
    }
    async getSnapshotById(id) {
        let snap = await this.snaps.findOne({ id });
        return Snap_1.default.parse(snap);
    }
    async getEventById(id) {
        let event = await this.events.findOne({ id });
        if (event) {
            return Event_1.default.parse(event);
        }
        else {
            return null;
        }
    }
    async findEventsBySagaId(sagaId) {
        let events = await this.events.find({ sagaId }).sort({ index: -1, date: -1 });
        return events.map(event => Event_1.default.parse(event));
    }
    async removeEventsBySagaId(sagaId) {
        await this.killSaga(sagaId);
        await this.events.remove({ sagaId });
    }
    async findFollowEvents(actorId, index) {
        let events = await this.events.find({ actorId, index: { $gt: index } }).sort({ index: -1, date: -1 });
        return events.map(event => Event_1.default.parse(event));
    }
    async _clear_for_test() {
        this.snaps.remove();
        this.events.remove();
        this.sagas.remove();
    }
}
exports.default = MongoEventStore;
//# sourceMappingURL=index.js.map